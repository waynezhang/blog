---
layout: post
title: 再看数据挖掘--关联分析
subtitle: 本系列属原创 转载请注明原著
date: 2016-11-14
author:     "Norris"
categories: blog
tags: [data mining]
---

# <center>关联分析</center>

# 1.概述

关联分析用于发现隐藏在大型数据集中的有意义的联系，所发现的联系可以用关联规则或频繁项集的形式表示。

进行关联分析的时候，需要处理两个关键问题：

1. 从大型事务数据集中发现模式可能在计算上要付出很高的代价。

2. 所发现的某些模式可能是虚假的，因为他们可能是偶然发生的。

接下来的讨论从上面两个问题展开，首先来说说第一个问题，解释关联分析相关的概念以及有效的挖掘这种模式的算法。


# 2. 问题的定义

前面简单说明了关联分析的定义，下面展开说明一下什么是关联规则。

## 2.1 二元表示

关联分析面对的是什么样的数据呢？

一个最最常见的例子就是啤酒尿布的故事，这也是关联规则的一个应用，面对这样的数据我们在「数据」一文中讲到是购物篮数据。购物篮数据有两个维度，一个是事务，一个是项集。购物篮数据类似列联表，分横纵两个维度，每一行代表一个事务，每一列代表一个项。那么购物篮里面的数据是什么样子呢？就是常见的二元变量（0，1变量），即该项是否出现在了该事务中，通常这样野蛮的表示一个事件是有问题的，就是非对称的问题，因为我们通常认为项在事务中出现比不出现更重要。同时，这样简单粗暴的用0、1表示，常常忽略数据某些重要方面，比如数量、价格等等。

## 2.2 支持度（support）&置信度（confidence）

先谈一个概念叫做支持度计数，即包含特定项集的事务个数。若以$$T={t_1,t_2,...,t_N}$$表示所有事务的集合，以$$\sigma$$表示支持度计数，那么有以下关系：

$$\sigma(X) = |\{t_i | X \subset t_i, t_i \in T \}|$$

其中 $$|\cdot|$$ 表示集合中元素的个数。

那么什么是支持度和置信度呢？

简单来说就是概率|频率（支持度）和条件概率（置信度）的概念。

支持度和置信度是用来描述关联规则的度量，关联规则是形如$$X \rightarrow Y$$的表达式，X、Y都是某个项集，而且是<u>**不相交**</u>的项集。

支持度用来确定给定数据集的频繁程度，支持度确定Y在包含X的事务中出现的频繁程度。

$$s(X \rightarrow Y)=\frac{\sigma(X \cup Y)}{N}$$

$$c(X \rightarrow Y)=\frac{\sigma(X \cup Y)}{\sigma(X)}$$


支持度用来保证规则的出现并不是偶然的，通常用来删除无意义的规则。置信度保证规则的可靠性。

**Tips**:

关联规则的推论并不必然蕴含因果关系，指标是规则前件与后件的项明显地同时出现。因果关系需要利用常识或其他知识补充来判断。

## 2.3 定义关联规则

关联规则怎么做呢？就一句话，关联规则就是找出支持度大于等于 minsup 并且置信度大于等于 minconf 的所有规则。其中 minsup 和 minconf 是对应支持度和置信度阈值。

是不是很简单，但是具体怎么做呢？要找到每一条规则然后分别计算置信度和支持度吗？

这确实是最简单粗暴的方法，但是其计算代价巨大。对于一个包含$$d$$个项的数据集中提取的可能规则的总数为：

$$R = 3^d - 2^{d+1} +1$$

为了避免不必要的计算，可以事先对规则进行剪枝。

首先我们将关联规则的算法分成两步，首先计算其支持度然后再计算其置信度。认真点来说就是以下两步：

1. 频繁项集产生。目标是发现所有满足最小支持度的项集，这些项集成为频繁项集。

2. 规则的产生。 目标是从上一步发现的频繁项集中提取满足最小置信度的所有规则，这些规则称为强规则。

通常来说，频繁项集产生的计算开销远大于生产规则所需的计算开销。接下来将详细描述这两个关联分析算法中的关键步骤。

# 3. 频繁项集的产生

假如我们执意使用枚举的方法产生频繁项集，那让我们来算一算。

对于包含k个项的数据集可能产$$2^k - 1$$个频繁项集，不包含空集在内（$$C_{k}^{1}+C_k^2+C_k^3+...+C_k^k$$)。而随着k的增大，这个计算量可以说是指数级的增长，需要搜索的空间也随之指数级的增长。那么我们来看看计算量具体是多少，
假如对于上述的k个项的数据集而言一共有N个事务与之对应，最大事务宽度是w，那么通过比较每个事务与每个可能项集的时间复杂度是O(NMw)，其中$$M=2^k-1$$是候选集数。

上面的时间复杂度中w是无法改变的事实，那么我们通过优化N、M来降低频繁项集产生的计算复杂度。

对于M，即减少候选项集的数目而言，我们采用先验原理（apriori）。对于减少比较次数而言，我们采用更高级的数据结构或者存储候选项集或者压缩数据集，接下来我们将详细说明这两个方面。

## 3.1 先验原理

> 先验原理: 如果一个项集是频繁的，则它的所有子集也一定是频繁的。

这个原理非常好理解，如果一个项集是频繁的，那么它的子集的支持度一定是大于它自己的，因为子集被包含的事务个数一定是更多的，所以如果一个项集是频繁的，那么它的所有子集也一定是频繁的。这个性质也称为支持度度量的反单调性。同样的它的逆否定理同样成立。

> 先验原理的逆否定理：如果一个项集是非频繁的，那么它的所有超集也一定是非频繁的。

这种基于支持度度量修剪指数搜索空间的策略成为基于支持度的剪枝。

## 3.2 Apriori算法的频繁项集产生

Apriori算法使用了基于支持度的剪枝方法来控制候选集的指数增长。具体步骤如下：

1. 扫描所有数据，得出所有**单**项集的支持度。

2. 将上一步中所有满足最小支持度的频繁项集进行组合得到2-项集。

3. 循环第二步直到没有新的频繁项集产生。

该算法有两个特点：第一，它是一个逐层算法，从频繁1-项集到最长的频繁项集，需要遍历所有长度项集的每一层；第二，它使用产生——测试的策略来发现频繁项集，每次迭代都通过前一次迭代产生的频繁项集产生，然后计算这次迭代所有项集的支持度并与minsup比较。

下面就算法中的具体细节展开说明。

### 3.2.1 候选的产生与剪枝

上面一小节说到Apriori算法中第二步是产生后算计并且对不满足最小支持度的项集进行剪枝，在这个过程中需要注意的是产生候选集的要求：

1. 避免产生太多不必要的候选集。候选集必须保证其所有真子集（这里我感觉书中的意思不是全部的真子集，而是全部的k-1项集，k是当前项集的宽度，因为关联规则的方法是逐层算法，只需要保证k-1阶即可保证全局最优解？）都是非频繁的，这样可以保证该候选集是频繁项集。

2. 保证候选集的集合是完全的，即必须包含所有应该出现的频繁项集。

3. 避免产生重复的候选集。例如一个4-项集{a,b,c,d}的产生可能有多种：{a}和{b,c,d}；{b,c}和{a,d}等等。

为了满足上述要求我们简述集中产生候选集的方法：

1. 蛮力方法。

	蛮力方法将所有的k-项集都看作候选集，然后再使用剪枝的方法去除不必要的项集。乍一看确实非常简单，但是计算开销巨大，下面来看看其时间复杂度。

	假设一共有d个项，那么使用蛮力方法可以产生$$C_d^k$$个k-项集集，每一个候选集可能产生k个k-1项集，然后每个k-1项集需要d个项比较来确定是否其真子集都是频繁项集。总结来说，这种方法的时间复杂度是$$O(\Sigma_{k=1}^dkC_d^k)=O(d\cdot2^{d-1})$$。

	可以看出这是一种指数型复杂度，非常"蛮力"！

2. $$F_{k-1} \times F_1$$ 方法。

	这种产生候选集的方法是利用频繁1-项集来扩展每个(k-1)-项集。这种方法将产生O(|F_{k-1}||F_1|)个候选k-项集。这种方法的复杂是$$O(\Sigma_k|F_{k-1}||F_1|)$$。

	相较于蛮力方法复杂度降低了不少，但是同样的非常容易产生重复候选项集。解决重复的方法可以利用字典编号的方法，将所有项进行编号，在进行k-项候选集的产生时，只选取比k-1项集中所有项编号都大的项进行组合，这样就可以避免重复问题。

	该方法另外一个缺点是，仍然会产生不必要的项集，例如将频繁2-项集{a,b}和c结合得到3-项集{a,b,c}，但是其真子集{a,c}却不是频繁2-项集，这样就会导致该3-项集也是非频繁项集。这样的情况下，我们的解决方法是：对于每一个幸免于剪枝的候选k-项集来说，它的每一个项必须至少在k-1个(k-1)-项集中出现，否则，该候选集就是非频繁的。解释一下就是，k-项集的所有(k-1)-项集子集必须出现在k-1频繁项集中，k项集中的每个元素起码出现两次才能保证其k-1项集有可能是频繁的，假如某个项只出现了一次，那么其必定有一个k-1项集的组合是非频繁的。**这个方法可以减少非频繁项集的产生，但是不能保证所有通过此方法得到的候选项集一定是频繁的。**

3. $$F_{k-1}\times F_{k-1}$$方法。

	这种候k项候选集产生的方法是合并一对频繁(k-1)-项集，仅当它们的前 k-2 个项都相同的时候。

	使用这种方法的一个先决条件是，候选项集产生的过程中必须使用了字典序方法进行组合。
	
	为什么一定要前 k-2 项都相同呢，和 $$F_{k-1} \times F_1$$ 方法中剪枝的思想类似，我们必须要求产生的k项集的所有k-1项集都是频繁的，那么当前k-2项都相同的时候，必然能保证其所有k-1项子集都是频繁的。可以想象一个产生3-项集的例子就很容易理解了。


### 3.2.2 支持度的计数

上一步产生了候选项集，那么如何筛选候选项集成为频繁项集呢？就需要计算其支持度与minsup的比较。

最容易想到的支持度计数方法就是通过比较每个事务与所有的候选集，并且相应的更新包含在事务中的候选项集的支持度计数。这种方法的计算方法是昂贵的。

不妨换个思路，我们先枚举出所有事务包含的项集，并且利用它们更新对应的候选项集的支持度。




**To Be Continued ...**








